options {
    STATIC = false;
}

PARSER_BEGIN(FldwCompiler)
package javacc;

import java.io.*;
import java.lang.reflect.*;
import core.*;import examples.Examples;

public class FldwCompiler {
    public static void main(String[] args) {
//        String[] tests={"a<1.2"};
//        for (String arg : tests) {
            try {
//                            Class.forName("std.Std");
                parse(Examples.BlockExample4);
//                System.out.println(evaluate(arg));
//                return(evaluate(arg));
            } catch (ParseException ex) {
                System.err.println(ex.getMessage());
            }
//        }
    }

    public static void parse(String src) throws ParseException {
        Reader reader = new StringReader(src);
//        Object ret = new FldwCompiler(reader).expr_data_tmp();
//        System.out.println(ret);
        new FldwCompiler(reader).program();
    }
}

PARSER_END(FldwCompiler)

/*****************************************************************/
/***************************词法分析*******************************/
/*****************************************************************/

SKIP : // Ignoring spaces/tabs/newlines
{
        " "
    |   "\t"
    |   "\n"
    |   "\r"
    |   "\f"
}

SPECIAL_TOKEN : // Ignoring line commit
{
    < LINE_COMMIT : "//"(~["\n","\r"])* ("\n"|"\r\n"|"\r")? >
}

TOKEN : // Keywords and punctuation
{
        < SEMIC : ";" >
    |   < COMMA : "," >

    |   < LBR : "(" >
    |   < RBR : ")" >
    |   < RCBR : "}" >
    |   < LCBR : "{" >
    |   < RSBR : "]" >
    |   < LSBR : "[" >

    |   < ASSIGN : "=" >
    |   < PLUS : "+" >
    |   < MINUS : "-" >
    |   < MULT : "*" >
    |   < DIV : "/" >
    |   < MOD : "%" >
    |   < INC : "++" >
    |   < DEC : "--" >

//    |   < EXLM : "!" >
    |   < LOGIC_EQUAL : "==" >
    |   < LOGIC_NOT : "!=" >
    |   < LOGIC_AND : "&&" >
    |   < LOGIC_OR : "||" >
    |   < LEFT : "<" >
    |   < RIGHT : ">" >
    |   < LEFT_EQUAL : "<=" >
    |   < RIGHT_EQUAL : ">=" >

    |   < IF : "if" >
    |   < ELSE : "else" >
//    |   < RETURN : "return" >
//    |   < STRING : "string" >
    |   < WHILE : "while" >
    |   < FOR : "for" >

    |   < FUNC : "function" >
//    |   < FUNC_IN : "in" >
//    |   < FUNC_OUT : "out" >

    |   < FLOWING : "|" >
    |   < MATCHING : "->" >

//    |   < STDIN : "stdin" >
//    |   < STDOUT : "stdout" >
    |   < IMPORT : "import" >
    |   < DOT : "." >
}

TOKEN : // value: int
{
    < INT_VALUE : ["1"-"9"] (["0"-"9"])*
            |   "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+
            |   "0" (["0"-"7"])*
            >
}

TOKEN : // value: double
{
    < DOUBLE_VALUE : ["1"-"9"] (["0"-"9"])*("."(["0"-"9"])*)? >
}

TOKEN : // value: bool
{
    < BOOL_VALUE : "true"|"false" >
}

MORE : // value: string
{
    < "\"" > : IN_STRING
}
< IN_STRING > MORE :
{
        < (~["\"", "\\", "\n", "\r"])+ >
    |   < "\\"(["0"-"7"]){3} >
    |   < "\\"~[] >
}
< IN_STRING > TOKEN :
{
    < STRING_VALUE : "\"" > : DEFAULT
}

TOKEN : // value: null
{
    < NULL_VALUE : "null" >
}

TOKEN : // symbol
{
    < SYMBOL : ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* >
}

TOKEN : // anything not recognised so far
{
    < OTHER : ~[] >
}

/*****************************************************************/
/***************************语法分析*******************************/
/*****************************************************************/
TerminalData terminal_data() :
{
    Token terminalToken;
    Datable.DataType type;
    TerminalData terminalData;
}
{
    // 语法：terminal_data() = < INT_VALUE > | < DOUBLE_VALUE > | < BOOL_VALUE > | < STRING_VALUE >
    (   terminalToken = < INT_VALUE >
        {
            type = Datable.DataType.Int;
        }
    |   terminalToken = < DOUBLE_VALUE >
        {
            type = Datable.DataType.Double;
        }
    |   terminalToken = < BOOL_VALUE >
        {
            type = Datable.DataType.Bool;
        }
    |   terminalToken = < STRING_VALUE >
        {
            type = Datable.DataType.String;
        }
    |   terminalToken = < NULL_VALUE > { type = null; }
    )
    {
        terminalData =  new TerminalData(type, terminalToken.image);
        terminalData.addToken(terminalToken.image);
        return terminalData;
    }
}

SymbolData symbol_data() :
{
    Token symbolToken;
    SymbolData symbolData;
}
{
    // 语法：symbol_data() = < SYMBOL>  | < SYMBOL> < EXLM >
    (symbolToken = < SYMBOL>)
    {
        symbolData = SymbolTable.CurrentSymbolTable().PutOrGetSymbol(symbolToken.image, SymbolTable.SymbolType.Data).assertGetSymbolData();
        symbolData.addToken(symbolToken.image);
        return symbolData;
    }
}

// TODO：tmp
ExprData expr_data_tmp() :
{
    Token leftDataToken;
    Token rightDataToken;
    Token opToken;
    ExprData exprData = new ExprData();
    Datable leftData, rightData;
}
{
    leftData = data()
    {
        exprData.setLeftData(leftData);
    }
    (
            < LEFT > { exprData.setOp(ExprData.ExprOp.LeftOp); }
        |   < RIGHT > { exprData.setOp(ExprData.ExprOp.RightOp); }
        |   < LEFT_EQUAL >
        |   < RIGHT_EQUAL >
        |   < LOGIC_EQUAL > { exprData.setOp(ExprData.ExprOp.LogicEqualOp); }
        |   < LOGIC_NOT > { exprData.setOp(ExprData.ExprOp.LogicNotOp); }
    )
    rightData = data()
    {
            exprData.setRightData(rightData);
    }
    {
        return exprData;
    }
}

Datable expr_data() :
{
    ExprData topExprData = new ExprData();
    Datable leftExprData = new ExprData();
    Datable rightExprData = new ExprData();
}
{
    leftExprData = expr1_data()
    (
        < LOGIC_OR > { topExprData.setOp(ExprData.ExprOp.LogicOrOp); }
        rightExprData = expr1_data()
        {
            topExprData.setLeftData(leftExprData);
            topExprData.setRightData(rightExprData);
            leftExprData = topExprData;
        }
    )*
    {
        return topExprData;
    }
}

Datable expr1_data() :
{
    ExprData topExprData = new ExprData();
    Datable leftExprData = new ExprData();
    Datable rightExprData = new ExprData();
}
{
    leftExprData = expr2_data()
    (
        < LOGIC_AND> { topExprData.setOp(ExprData.ExprOp.LogicAndOp); }
        rightExprData = expr2_data()
        {
            topExprData.setLeftData(leftExprData);
            topExprData.setRightData(rightExprData);
            leftExprData = topExprData;
        }
    )*
    {
        return topExprData;
    }
}

Datable expr2_data() :
{
    ExprData topExprData = new ExprData();
    Datable leftExprData = new ExprData();
    Datable rightExprData = new ExprData();
}
{
    leftExprData = expr3_data()
    (
        (   < LEFT > { topExprData.setOp(ExprData.ExprOp.LeftOp); }
        |   < RIGHT > { topExprData.setOp(ExprData.ExprOp.RightOp); }
        |   < LEFT_EQUAL > { topExprData.setOp(ExprData.ExprOp.LeftEqualOp); }
        |   < RIGHT_EQUAL > { topExprData.setOp(ExprData.ExprOp.RightEqualOp); }
        |   < LOGIC_EQUAL > { topExprData.setOp(ExprData.ExprOp.LogicEqualOp);}
        |   < LOGIC_NOT > { topExprData.setOp(ExprData.ExprOp.LogicNotOp);}
         )
        rightExprData = expr3_data()
        {
            topExprData.setLeftData(leftExprData);
            topExprData.setRightData(rightExprData);
            leftExprData = topExprData;
        }
    )*
    {
        return topExprData;
    }
}

Datable expr3_data() :
{
    ExprData topExprData = new ExprData();
    Datable leftExprData;
    Datable rightExprData = null;
}
{
    leftExprData = expr4_data()
    (
        (   < PLUS > { topExprData.setOp(ExprData.ExprOp.AddOp); }
        |   < MINUS > { topExprData.setOp(ExprData.ExprOp.SubOp); }
        )
        rightExprData = expr4_data()
        {
            topExprData.setLeftData(leftExprData);
            topExprData.setRightData(rightExprData);
            leftExprData = new SymbolData();
            leftExprData.Push(topExprData);
        }
    )*
    {
        if (rightExprData != null) {
            return topExprData;
        } else {
            return leftExprData;
        }
    }
}

Datable expr4_data() :
{
    ExprData topExprData = new ExprData();
    Datable leftExprData;
    Datable rightExprData = null;
}
{
    leftExprData = term()
    (
        (   < MULT > { topExprData.setOp(ExprData.ExprOp.MulOp); }
        |   < DIV > { topExprData.setOp(ExprData.ExprOp.DivOp); }
        )
        rightExprData = term()
        {
            topExprData.setLeftData(leftExprData);
            topExprData.setRightData(rightExprData);
            leftExprData = new SymbolData();
            leftExprData.Push(topExprData);
        }
    )*
    {
        if (rightExprData != null) {
            return topExprData;
        } else {
            return leftExprData;
        }
    }
}

Datable term() :
{
    Datable data;
}
{
    (    data = terminal_data()
    |    data = symbol_data()
    |    < LBR > data = expr_data() < RBR >
    )
    {
        return data;
    }
}

Datable data() :
{
    Datable data;
}
{
    // 语法：data() = terminal_data() | symbol_data() | expr_data_tmp()
    (    data = terminal_data()
    |    data = symbol_data()
    )
    {
        return data;
    }
}

ListFlow list_flow() :
{
    ListFlow listFlow = new ListFlow();
    Datable data;
}
{
    // 语法：list_flow() = < LSBR  > data() ( < COMMA > data() )* < RSBR >
    < LSBR  >
//    data = data()
//    {
//        listFlow.Push(data);
//    }
    ( [< COMMA >] data = data()
        {
            listFlow.Push(data);
        }
    )*
    < RSBR >
    {
//        System.out.println(listFlow);
        return listFlow;
    }
}

//SymbolFlow symbol_flow() :
//{
//}
//{
//    // 语法：symbol_flow() = < ITER> <SYMBOL> stmt()
//    {
////        System.out.println(new SymbolFlow());
//        return new SymbolDataFlow();
//    }
//}

IfElseFlow if_else_flow() :
{
    ExprData conditionData;
    Flowable trueFlow;
    Flowable falseFlow = null;
}
{
    // 语法：if_else_stmt() = < IF > < LBR > expr_data_tmp() < RBR > block() [ <ELSE > block() ]
    < IF > < LBR > conditionData = expr_data_tmp() < RBR > trueFlow = block_flow() [ <ELSE > falseFlow = block_flow() ]
    {
        return new IfElseFlow(conditionData, trueFlow, falseFlow);
    }
}

WhileFlow while_flow() :
{
    ExprData conditionData;
    Flowable trueFlow;
}
{
    // 语法：< WHILE > < LBR > expr_data_tmp() < RBR > block()
    < WHILE > < LBR > conditionData = expr_data_tmp() < RBR > trueFlow = block_flow()
    {
        return new WhileFlow(conditionData, trueFlow);
    }
}

ForFlow for_flow() :
{
    Flowable iterFlow;
    SymbolData iterSymbolData;
    BlockFlow forBlockFlow;
    ForFlow forFlow;
}
{
    // 语法：for_flow() = < FOR > < LBR > flow() < FLOWING > symbol_data() < RBR > block_flow()
    < FOR > < LBR > iterFlow = flow() < MATCHING > iterSymbolData = symbol_data() < RBR > forBlockFlow = block_flow()
    {
        forFlow = new ForFlow(iterFlow, iterSymbolData, forBlockFlow);
        return forFlow;
    }
}

FuncFlow func_flow() :
{
    Token funcSymbol;
    ListFlow paramFlow = null;
    FuncFlow funcFlow;
}
{
    funcSymbol = < SYMBOL > < LBR > [ paramFlow = list_flow()] < RBR >
    {
        funcFlow = SymbolTable.CurrentSymbolTable().RecurseGetSymbol(funcSymbol.image).assertGetFuncFlow();
        if (paramFlow != null) {
            funcFlow.setParamFlow(paramFlow);
        }
        return funcFlow;
    }
}

HeadTailFlow head_tail_flow() :
{
    SymbolData headData;
    Token tailListFlowSymbol;
    Flowable tailListFlow;
    HeadTailFlow headTailFlow;
}
{
    // 语法：head_tail_flow() = < LSBR  > symbol_data() < SEMIC > < SYMBOL> < RSBR >
    < LSBR  > headData = symbol_data() < SEMIC >
    tailListFlowSymbol = < SYMBOL>
    {
        tailListFlow = SymbolTable.CurrentSymbolTable().PutOrGetSymbol(tailListFlowSymbol.image, SymbolTable.SymbolType.Flow).assertGetFlowable();
    }
    < RSBR >
    {
        return new HeadTailFlow(headData, tailListFlow);
    }
}

BlockFlow block_flow() : // block 不能嵌套
{
    BlockFlow blockFlow;
    Flowable topFlow;
}
{
    // 语法：block() = < LCBR > (flowing)* < RCBR > [ < EXLM > ]
    < LCBR > { Core.AddEager(); SymbolTable.EnterBlock(null); blockFlow = new BlockFlow();}
//    ( import_stmt() )*
    (
//        LOOKAHEAD(3) topFlow = flowing() { blockFlow.addFlow(topFlow); }
       topFlow = flowing() { blockFlow.addFlow(topFlow); }
    )*
//    stmts()
    < RCBR > { Core.SubEager(); SymbolTable.ExitBlock(); }
//    [ < EXLM > { blockFlow.Flowing(); } ]
    {
//        System.err.println("blcokFlow: "+blockFlow);
        return blockFlow;
    }
}

Flowable flow() :
{
    Flowable flow = new ListFlow();
    Token flowSymbol;
}
{
    // 语法：flow() = list_flow() | symbol_flow() | func_flow()
    (

//        LOOKHEAD 的要放在最前面
        LOOKAHEAD(2) flow = func_flow() // 预读 < SYMBOL > < LBR >
    |   LOOKAHEAD(3) flow = head_tail_flow() // 预读 < LSBR > < SYMBOL > <SEMIC >
    |   flowSymbol = < SYMBOL>
        {
            flow = SymbolTable.CurrentSymbolTable().PutOrGetSymbol(flowSymbol.image, SymbolTable.SymbolType.Flow).assertGetFlowable();
        }
    |   flow = list_flow()
    |   flow = if_else_flow()
    |   flow = while_flow()
    |   flow = block_flow()
    |   flow = for_flow()
    )
    {
        return flow;
    }
}

Flowable flowing() :
{
    Flowable topFlow = new ListFlow();
    Flowable leftFlow = new ListFlow();
    Flowable rightFlow = new ListFlow();
}
{
    // 语法：match_flow() = flow() < FLOWING > flow()
    topFlow = flow()
    {
        leftFlow = topFlow;
    }
    (
        LOOKAHEAD(1) ( // TODO Why lookahead
            < MATCHING > { leftFlow.SetFlowOp(Flowable.FlowOp.Matching);}
        |   < FLOWING >  { leftFlow.SetFlowOp(Flowable.FlowOp.Pushing);}
        )
    rightFlow = flow()
    {
        leftFlow.SetNextFlowing(rightFlow);
//                                        System.err.println(leftFlow.GetSymbol() +leftFlow.GetIdentity()+ "->"+rightFlow.GetSymbol()+rightFlow.GetIdentity());
//                                        System.err.println("leftFlow:\n"+leftFlow);
//                                        System.err.println("rightFlow:\n"+rightFlow);
//                                        System.err.println("symboltable:\n"+SymbolTable.CurrentSymbolTable());
        leftFlow = rightFlow;
    }
    )*
    {
//        System.out.println("Root Symbol Table: " + SymbolTable.CurrentSymbolTable());
//        System.out.println("before flowing: " + topFlow);
        if (Core.IsEager()) {
//            System.out.println("eager! flowing");
            topFlow.Flowing();
        }
//        System.out.println("after flowing: " + topFlow);
//                                        System.err.println("topFlow:\n"+topFlow);
//                                                System.err.println("symboltable:\n"+SymbolTable.CurrentSymbolTable());
        return topFlow;
    }
}

Flowable matching() :
{
    Flowable topFlow = new ListFlow();
    Flowable leftFlow = new ListFlow();
    Flowable rightFlow = new ListFlow();
}
{
    // 语法：matching() = flow() < rightFlow > flow()
    topFlow = flowing()
    {
//        System.err.println("matching");
        leftFlow = topFlow;
    }
    (< MATCHING >
    rightFlow = flowing()
    {
        leftFlow.SetNextMatching(rightFlow);
        leftFlow = rightFlow;
    }
    )*
    {
        if (Core.IsEager()) {
            topFlow.Matching();
        }
        return topFlow;
    }
}

void def_func_stmt() : // 函数就是一个有参数和符号关联的 Block
{
    Token funcSymbol;
    int count = 0;
    Token curToken;
    StringBuffer funcBuf = new StringBuffer();
}
{
    // 语法：def_func_stmt() = < FUNC > < SYMBOL > < LBR > [ list_flow() ] < RBR > block_flow()
    < FUNC > funcSymbol = < SYMBOL >
    {
        do{
            curToken = token_source.getNextToken();
            funcBuf.append(curToken);
            funcBuf.append(" ");
        } while (curToken.image!= ")");
        curToken = token_source.getNextToken();
        if (curToken.image=="{"){
            funcBuf.append(curToken);
            funcBuf.append(" ");
            count++;
            do{
                curToken = token_source.getNextToken();
                funcBuf.append(curToken);
                funcBuf.append(" ");
                if (curToken.image=="{") {
                    count++;
                } else if (curToken.image=="}") {
                    count--;
                }
            }while (count!=0);
        }
    }
    {
//        System.err.println(funcBuf);
        SymbolTable.CurrentSymbolTable().PutSymbol(funcSymbol.image, SymbolTable.SymbolType.Function, funcBuf.toString());
    }
}

FuncFlow make_func_flow() : // 函数就是一个有参数和符号关联的 Block
{
    ListFlow param_flow = null;
    BlockFlow block_flow;
}
{
    // 语法：def_func_stmt() = < FUNC > < SYMBOL > < LBR > [ list_flow() ] < RBR > block_flow()
    < LBR > { SymbolTable.EnterBlock(null); }
    [ param_flow = list_flow() ]
    < RBR >
    block_flow = block_flow() { SymbolTable.ExitBlock(); }
    {
        FuncFlow f = new FuncFlow(param_flow, block_flow);
        return f;
    }
}

void import_stmt() :
{
    Token package_name;
    Token module_name;
}
{
    // 语法：import_stmt() = < IMPORT > < STRING_VALUE >
    < IMPORT >
    package_name = < SYMBOL >
    < DOT >
    module_name = < SYMBOL >
    {
        try {
             Class<?> clazz = Class.forName(package_name.image + "." + module_name.image);
             Method loadModule = clazz.getMethod(Core.ModuleLoadFunc);
             loadModule.invoke(null);
        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | IllegalAccessException ex) {
            throw new RuntimeException(ex.getMessage());
        }
    }
}

void stmt() :
{
}
{
        flowing()
    |   def_func_stmt()
    |   import_stmt() //| block_flow()
    {
        return;
    }
}

void stmts() :
{
}
{
    ( stmt() )*
    {
        return;
    }
}



void program() :
{
}
{
    stmts() < EOF >
    {
        return;
    }
}
