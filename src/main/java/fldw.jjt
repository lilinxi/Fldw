options {
    STATIC = false;
}

PARSER_BEGIN(FldwCompiler)
import java.io.*;
import core.*;

public class FldwCompiler {
    public static void main(String[] args) {
//        String[] tests={"a<1.2"};
//        for (String arg : tests) {
            try {
                evaluate(Examples.FlowingExample4);
//                System.out.println(evaluate(arg));
//                return(evaluate(arg));
            } catch (ParseException ex) {
                System.err.println(ex.getMessage());
            }
//        }
    }

    public static void evaluate(String src) throws ParseException {
        Reader reader = new StringReader(src);
//        Object ret = new FldwCompiler(reader).expr_data();
//        System.out.println(ret);
        new FldwCompiler(reader).program();
    }
}

PARSER_END(FldwCompiler)

/*****************************************************************/
/***************************词法分析*******************************/
/*****************************************************************/

SKIP : // Ignoring spaces/tabs/newlines
{
        " "
    |   "\t"
    |   "\n"
    |   "\r"
    |   "\f"
}

SPECIAL_TOKEN : // Ignoring line commit
{
    < LINE_COMMIT : "//"(~["\n","\r"])* ("\n"|"\r\n"|"\r")? >
}

TOKEN : // Keywords and punctuation
{
        < SEMIC : ";" >
    |   < COMMA : "," >

    |   < LBR : "(" >
    |   < RBR : ")" >
    |   < RCBR : "}" >
    |   < LCBR : "{" >
    |   < RSBR : "]" >
    |   < LSBR : "[" >

    |   < ASSIGN : "=" >
    |   < PLUS : "+" >
    |   < MINUS : "-" >
    |   < MULT : "*" >
    |   < DIV : "/" >
    |   < MOD : "%" >
    |   < INC : "++" >
    |   < DEC : "--" >

    |   < EXLM : "!" >
    |   < LOGIC_EQUAL : "==" >
    |   < LOGIC_NOT : "!=" >
    |   < LOGIC_AND : "&&" >
    |   < LOGIC_OR : "||" >
    |   < LEFT : "<" >
    |   < RIGHT : ">" >
    |   < LEFT_EQUAL : "<=" >
    |   < RIGHT_EQUAL : ">=" >

    |   < IF : "if" >
    |   < ELSE : "else" >
//    |   < RETURN : "return" >
//    |   < STRING : "string" >
    |   < WHILE : "while" >
    |   < FUNC : "function" >

    |   < FLOW : "|" >
    |   < ITER : "->" >
}

TOKEN : // value: int
{
    < INT_VALUE : ["1"-"9"] (["0"-"9"])*
            |   "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+
            |   "0" (["0"-"7"])*
            >
}

TOKEN : // value: double
{
    < DOUBLE_VALUE : ["1"-"9"] (["0"-"9"])*("."(["0"-"9"])*)? >
}

TOKEN : // value: bool
{
    < BOOL_VALUE : "true"|"false" >
}

MORE : // value: string
{
    < "\"" > : IN_STRING
}
< IN_STRING > MORE :
{
        < (~["\"", "\\", "\n", "\r"])+ >
    |   < "\\"(["0"-"7"]){3} >
    |   < "\\"~[] >
}
< IN_STRING > TOKEN :
{
    < STRING_VALUE : "\"" > : DEFAULT
}

TOKEN : // symbol
{
    < SYMBOL : ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* >
}

TOKEN : // anything not recognised so far
{
    < OTHER : ~[] >
}

/*****************************************************************/
/***************************语法分析*******************************/
/*****************************************************************/
TerminalData terminal_data() :
{
    Datable.DataType type;
    Token x;
}
{
    // 语法：terminal_data() = < INT_VALUE > | < DOUBLE_VALUE > | < BOOL_VALUE > | < STRING_VALUE >
    (   x = < INT_VALUE >
        {
            type = Datable.DataType.Int;
        }
    |   x = < DOUBLE_VALUE >
        {
            type = Datable.DataType.Double;
        }
    |   x = < BOOL_VALUE >
        {
            type = Datable.DataType.Bool;
        }
    |   x = < STRING_VALUE >
        {
            type = Datable.DataType.String;
        }
    )
    {
        return new TerminalData(type, x.image);
    }
}

SymbolData symbol_data() :
{
    Token x;
}
{
    // 语法：symbol_data() = < SYMBOL>
    x = < SYMBOL>
    {
        return new SymbolData(x.image);
    }
}

// tmp
ExprData expr_data() :
{
    ExprData exprData = new ExprData();
    Datable leftData, rightData;
}
{
    leftData = data()
    {
        exprData.setLeftData(leftData);
    }
    (
            < LEFT > { exprData.setOp(ExprData.ExprOp.LeftOp); }
        |   < RIGHT > { exprData.setOp(ExprData.ExprOp.RightOp); }
        |   < LEFT_EQUAL >
        |   < RIGHT_EQUAL >
    )
    rightData = data()
    {
            exprData.setRightData(rightData);
    }
    {
        return exprData;
    }
}

Datable data() :
{
    Datable data;
}
{
    // 语法：data() = terminal_data() | symbol_data() | expr_data()
    (    data = terminal_data()
    |    data = symbol_data()
    )
    {
        return data;
    }
}

ListFlow list_flow() :
{
    ListFlow listFlow = new ListFlow();
    Datable data;
}
{
    // 语法：list_flow() = < LSBR  > data() ( < COMMA > data() )* < RSBR >
    < LSBR  >
    data = data()
    {
        listFlow.Push(data);
    }
    ( < COMMA > data = data()
        {
            listFlow.Push(data);
        }
    )*
    < RSBR >
    {
//        System.out.println(listFlow);
        return listFlow;
    }
}

SymbolFlow symbol_flow() :
{
}
{
    // 语法：symbol_flow() = < ITER> <SYMBOL> stmt()
    {
//        System.out.println(new SymbolFlow());
        return new SymbolFlow();
    }
}

IfElseFlow if_else_flow() :
{
}
{
    {
//        System.out.println(new IfElseFlow());
        return new IfElseFlow();
    }
}

FuncFlow func_flow() :
{
}
{
    symbol_data() < LBR > < RBR >
    {
//        System.out.println(new FuncFlow());
        return new FuncFlow();
    }
}

HeadTailFlow head_tail_flow() :
{
    SymbolData headData;
    Token tailListFlowSymbol;
    ListFlow tailListFlow;
    HeadTailFlow headTailFlow;
}
{
    // 语法：head_tail_flow() = < LSBR  > symbol_data() < SEMIC > < SYMBOL> < RSBR >
    < LSBR  > headData = symbol_data() < SEMIC >
    tailListFlowSymbol = < SYMBOL>
    {
        tailListFlow = new ListFlow(tailListFlowSymbol.image);
        SymbolTable.RootSymbolTable.PutSymbol(tailListFlowSymbol.image, SymbolTable.SymbolType.Flow, tailListFlow);
    }
    < RSBR >
    {
        return new HeadTailFlow(headData, tailListFlow);
    }
}

Flowable flow() :
{
    Flowable flow = new ListFlow();
    Token flowSymbol;
}
{
    // 语法：flow() = list_flow() | symbol_flow() | func_flow()
    (

//        LOOKHEAD 的要放在最前面
        LOOKAHEAD(3) flow = func_flow()
    |   LOOKAHEAD(3) flow = head_tail_flow()
    |   flowSymbol = < SYMBOL>
        {
            flow = new ListFlow(flowSymbol.image);
            SymbolTable.RootSymbolTable.PutSymbol(flowSymbol.image, SymbolTable.SymbolType.Flow, flow);
        }
    |   flow = list_flow()
    )
    {
        return flow;
    }
}

Flowable flowing() :
{
    Flowable topFlow = new ListFlow();
    Flowable leftFlow = new ListFlow();
    Flowable rightFlow = new ListFlow();
}
{
    // 语法：match_flow() = flow() < FLOW > flow()
    topFlow = flow()
    {
        leftFlow = topFlow;
    }
    (< FLOW >
    rightFlow = flow()
    {
        leftFlow.SetNext(rightFlow);
        leftFlow = rightFlow;
    }
    )*
    {
        System.out.println("Root Symbol Table: " + SymbolTable.RootSymbolTable);
        System.out.println("before flowing: " + topFlow);
        topFlow.Flowing();
        System.out.println("after flowing: " + topFlow);
        return topFlow;
    }
}

void if_else_stmt() :
{
}
{
    // 语法：if_else_stmt() = < IF > < LBR > expr_data() < RBR > block() [ <ELSE > block() ]
    < IF > < LBR > expr_data() < RBR > block() [ <ELSE > block() ]
    {
        return;
    }
}

void while_stmt() :
{
}
{
    // 语法：< WHILE > < LBR > expr_data() < RBR > block()
    < WHILE > < LBR > expr_data() < RBR > block()
    {
        return;
    }
}

void def_func_stmt() :
{
}
{
    // 语法：< FUNC > symbol_data() < LBR > (symbol_data())* < RBR > block()
    < FUNC > symbol_data() < LBR > (symbol_data())* < RBR > block()
    {
        return;
    }
}

void stmt() :
{
}
{
    flowing() | if_else_stmt() | while_stmt() | def_func_stmt()
    {
        return;
    }
}

void stmts() :
{

}
{
    (stmt())*
    {
        return;
    }
}

void block() :
{
}
{
    < LCBR > stmts() < RCBR >
    {
        return;
    }
}

void program() :
{
}
{
    stmts() < EOF >
    {
        return;
    }
}



//SKIP: { <[" ", "\t", "\r", "\n"]> }
//TOKEN: {
//    <INTEGER: (["0"-"9"])+>
//}
//
//long expr():
//{
//    Token x, y;
//}
//{
//    x=<INTEGER> "+" y=<INTEGER> <EOF>
//    {
//        return Long.parseLong(x.image) + Long.parseLong(y.image);
//    }
//}
